######################################
######## DECLARATIONS ################
######################################
# Get the index in FRAME that is LAGSEC lagged behind TIME, starting to look from START.  TIME is a difftime class (see as.difftime(x,units="y"))).  Let FRAME be the full data frame we're searching through.
getLagIndex = function(frame,time,lagsec,start) {
# Create placeholder vectors.
ftime = frame$time
last = start
# iterate through the array.
for (i in (start+1):length(ftime)) {
# If the frame's time is NA, do nothing.  There are many NAs in our data.
if (!is.na(ftime[i])) {
# If the frame's time is already ahead of the time we want, skip it.  All times are chronological, so once we find a single frame time ahead of our time, we can go straight to NA.
if (as.double(time - ftime[i],units="secs") >= 0) {
# If the frame's time is behind time, keep iterating until we find a time such that the last non-NA time is too far lagged and this time is lagged enough.  Return that time.
if ((as.double(time - ftime[last],units="secs") > lagsec) & (as.double(time - ftime[i],units="secs") <= lagsec)) {
return(i)
}
# If ever we get past time, return NA because no later frame times will be correct.
} else {
return(NA)
}
# As long as ftime[i] was not NA, we should remember it as the last non-NA time index.
last = i
}
}
# If somehow we reach the end of the array without finding a good time, return NA.
return(NA)
}
# Let FRAME be the full frame of things we're searching through. Let LAG be a difftime object created by as.difftime(x,units="y")
getFutureLagged = function(futures,frame,lag) {
# Create placeholdee vectors.
indepTime = futures$time
fulag1 = rep(NA,length(indepTime))
indices = rep(NA,length(indepTime))
# Iterate through the array.
for (i in 1:length(indepTime)) {
# Let the lagged index for i be given by getLagIndex.  Start the search at one before the last index for which we found something.
newInd = getLagIndex(frame,indepTime[i],lag,max(2,indices,na.rm=TRUE)-1)
# If no lagged index was found, let index be the value of the last known good index to start from, or let it be 1 if there is no last known good index.
if (is.na(newInd)) {
indices[i] = max(1,indices,na.rm=TRUE)
fulag[i] = NA
# If we found a lagged index, let fulag[i] be the close price at that index, and let it be known that the next solution will be found near here.
} else {
indices[i] = newInd
fulag[i] = frame$close[newInd]
}
}
return(fulag1)
}
getwd()
setwd("./Raw Data/")
dir
dir()
for (i in 1:300) {
eval(parse(text=paste("stock",i," = read.csv(\'",as.character(i),"\',as.is=TRUE)",sep="")))
eval(parse(text=paste("names(stock",i,") = stock",i,"[2,]",sep="")))
eval(parse(text=paste("stock",i," = stock",i,"[-(1:2),1:4]",sep="")))
eval(parse(text=paste("stock",i,"$close = as.numeric(stock",i,"$close)",sep="")))
eval(parse(text=paste("stock",i,"$volume = as.numeric(stock",i,"$volume)",sep="")))
eval(parse(text=paste("stock",i,"$amt = as.numeric(stock",i,"$amt)",sep="")))
eval(parse(text=paste("stock",i,"$time = as.POSIXct(strptime(stock",i,"$time,\'%Y-%m-%d %H:%M\'))",sep="")))
}
future10 = read.csv("future_10min.csv",colClasses=c("character","character","numeric","numeric","numeric","numeric","numeric"),col.names=c('d','t','open','high','low','close','volume'))
future10 = cbind(future10,time=paste(future10$d,future10$t))
future10$time = as.character(future10$time)
future10$time = as.POSIXct(strptime(future10$time,'%m/%d/%Y %I:%M:%S %p'))
future5 = read.csv("future_5min.csv",colClasses=c("character","character","numeric","numeric","numeric","numeric","numeric","numeric"),col.names=c('d','t','open','high','low','close','volume','volume2'))
future5 = cbind(future5,time=paste(future5$d,future5$t))
future5$time = as.character(future5$time)
future5$time = as.POSIXct(strptime(future5$time,'%m/%d/%Y %I:%M:%S %p'))
View(future10)
future10.sub <- future10(1:500,)
future10.sub <- future10[1:500,]
future5.sub <- future5[1:500,]
lag5 <- getFutureLagged(future5.sub, future5.sub, as.difftime(5, unit="mins"))
# Let FRAME be the full frame of things we're searching through. Let LAG be a difftime object created by as.difftime(x,units="y")
getFutureLagged = function(futures,frame,lag) {
# Create placeholdee vectors.
indepTime = futures$time
fulag = rep(NA,length(indepTime))
indices = rep(NA,length(indepTime))
# Iterate through the array.
for (i in 1:length(indepTime)) {
# Let the lagged index for i be given by getLagIndex.  Start the search at one before the last index for which we found something.
newInd = getLagIndex(frame,indepTime[i],lag,max(2,indices,na.rm=TRUE)-1)
# If no lagged index was found, let index be the value of the last known good index to start from, or let it be 1 if there is no last known good index.
if (is.na(newInd)) {
indices[i] = max(1,indices,na.rm=TRUE)
fulag[i] = NA
# If we found a lagged index, let fulag[i] be the close price at that index, and let it be known that the next solution will be found near here.
} else {
indices[i] = newInd
fulag[i] = frame$close[newInd]
}
}
return(fulag)
}
lag5 <- getFutureLagged(future5.sub, future5.sub, as.difftime(5, unit="mins"))
lag5
View(future5)
lag10 <- getFutureLagged(future10.sub, future10.sub, as.difftime(10, unit="mins"))
lag10
future5.sub <- future5[1:1000,]
lag5 <- getFutureLagged(future5.sub, future5.sub, as.difftime(5, unit="mins"))
lag10 <- getFutureLagged(future10.sub, future10.sub, as.difftime(10, unit="mins"))
lag5
lag10
master <- dataframe()
master
master <- data.frame()
master
View(future5)
View(future5)
View(future5)
master <- data.frame(close <- future5.sub$close, time <- future5.sub$time)
View(master)
master <- data.frame(close = future5.sub$close, time = future5.sub$time)
View(master)
View(future10.sub)
close <- future5.sel$close
lagClose <- getFutureLagged(future5.sub, future5.sub, as.difftime(5, unit="mins"))
rm(future10.sub, future5.sub)
future10.sel <- future10[1:500,]
future5.sel <- future5[1:1000,]
close <- future5.sel$close
close
lagClose <- getFutureLagged(future5.sel, future5.sel, as.difftime(5, unit="mins"))
lagClose
response <- close - lagClose
response
close
lagClose
lagClose <- getFutureLagged(future5.sel, future5.sel, as.difftime(10, unit="mins"))
lagClose
lagClose <- getFutureLagged(future5.sel, future5.sel, as.difftime(15, unit="mins"))
lagClose
as.difftime(15, unit="mins")
lagClose <- getFutureLagged(future5.sel, future5.sel, as.difftime(5, unit="mins"))
lagClose
lagClose <- getFutureLagged(future5.sel, future5.sel, as.difftime(5, unit="mins"))
response <- close - lagClose
evars1 <- data.frame(response = response, time = future5.sel$time)
evars1
response
lagClose <- getFutureLagged(future5.sel, future5.sel, as.difftime(5, unit="mins"))
lagClose <- getFutureLagged(future5.sel, future5.sel, as.difftime(10, unit="mins"))
lagClose
